<!DOCTYPE html>
<html lang="fr">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>üéÆ Shifumi AI - Jeu de Pierre-Feuille-Ciseaux</title>
    <script src="https://cdnjs.cloudflare.com/ajax/libs/socket.io/4.6.1/socket.io.js"></script>
    <link rel="stylesheet" href="{{ url_for('static', filename='style.css') }}">
    <link rel="preconnect" href="https://fonts.googleapis.com">
    <link rel="preconnect" href="https://fonts.gstatic.com" crossorigin>
    <link href="https://fonts.googleapis.com/css2?family=Poppins:wght@300;400;600;700;800&display=swap" rel="stylesheet">
</head>
<body>
    <div class="container">
        <div class="header">
            <h1 class="title">üéÆ Shifumi AI</h1>
        </div>

        <div class="game-layout">
            <!-- Panneau de gauche - Gestes d√©tect√©s -->
            <div class="gestures-panel">
                <div class="gestures-header">
                    <h3>ü§è Gestes D√©tect√©s</h3>
                </div>
                
                <div class="current-detection">
                    <div class="detection-label">Main d√©tect√©e:</div>
                    <div class="detected-hand" id="detected-hand">
                        <span class="hand-status" id="hand-status">‚ùå Aucune main</span>
                    </div>
                </div>
                
                <div class="gesture-detection">
                    <div class="detection-label">Geste actuel:</div>
                    <div class="current-gesture-display" id="current-gesture-display">
                        <span class="gesture-emoji" id="gesture-emoji">ü§∑</span>
                        <span class="gesture-name" id="gesture-name">En attente</span>
                    </div>
                </div>
                
                <div class="last-round-gestures" id="last-round-section" style="display: none;">
                    <div class="detection-label">Dernier round:</div>
                    <div class="round-comparison">
                        <div class="player-gesture-choice">
                            <div class="choice-label">Vous</div>
                            <div class="choice-gesture" id="player-choice">
                                <span class="choice-emoji" id="player-choice-emoji">‚ùì</span>
                                <span class="choice-name" id="player-choice-name">-</span>
                            </div>
                        </div>
                        <div class="vs-indicator">VS</div>
                        <div class="computer-gesture-choice">
                            <div class="choice-label">IA</div>
                            <div class="choice-gesture" id="computer-choice">
                                <span class="choice-emoji" id="computer-choice-emoji">‚ùì</span>
                                <span class="choice-name" id="computer-choice-name">-</span>
                            </div>
                        </div>
                    </div>
                    <div class="round-result" id="round-result-indicator">
                        <span id="round-winner-text">-</span>
                    </div>
                </div>
            </div>
            
            <!-- Panneau central - Jeu principal -->
            <div class="game-board">
                <div class="scores">
                    <div class="score-card player-score">
                        <div class="score-label">üë§ Vous</div>
                        <div class="score-number" id="player-score">0</div>
                    </div>
                    <div class="score-card computer-score">
                        <div class="score-label">ü§ñ IA</div>
                        <div class="score-number" id="computer-score">0</div>
                    </div>
                </div>

                <div id="game-status" class="game-status">Premier √† 5 points gagne la partie !</div>
                <div id="round-info" class="round-info">Cliquez sur "Lancer la partie" pour commencer</div>

                <div class="camera-section">
                    <div class="camera-controls">
                        <button class="btn" onclick="toggleCamera()">üìπ Activer Cam√©ra</button>
                        <button class="btn danger" onclick="stopCamera()">üõë Arr√™ter Cam√©ra</button>
                    </div>
                    
                    <div class="camera-container">
                        <video id="video" width="640" height="480" autoplay></video>
                        <canvas id="canvas" width="640" height="480" style="display: none;"></canvas>
                        <div class="camera-overlay" id="camera-status">Cam√©ra inactive</div>
                    </div>
                </div>

                <div class="controls">
                    <button id="play-button" class="play-button" onclick="startGameRound()">üöÄ D√©marrer les rounds automatiques</button>
                    <button id="stop-button" class="stop-button" onclick="stopAutoRounds()" style="display: none;">‚èπÔ∏è Arr√™ter les rounds automatiques</button>
                </div>
            </div>

            <div class="history-panel">
                <h3>üìã Historique des Rounds</h3>
                <div class="history-stats">
                    <div class="stat">
                        <span class="stat-label">Rounds jou√©s:</span>
                        <span class="stat-value" id="total-rounds">0</span>
                    </div>
                    <div class="stat">
                        <span class="stat-label">Victoires:</span>
                        <span class="stat-value" id="player-wins">0</span>
                    </div>
                    <div class="stat">
                        <span class="stat-label">D√©faites:</span>
                        <span class="stat-value" id="computer-wins">0</span>
                    </div>
                    <div class="stat">
                        <span class="stat-label">√âgalit√©s:</span>
                        <span class="stat-value" id="draws">0</span>
                    </div>
                </div>
                <div class="history-list" id="history-list">
                    <div class="history-placeholder">Aucun round jou√©</div>
                </div>
            </div>
        </div>
    </div>

    <!-- Particles Background -->
    <div class="particles" id="particles"></div>

    <script>
        // Variables globales
        const socket = io();
        let cameraActive = false;
        let stream = null;
        let detectionInterval = null;
        
        // Gestionnaire d'√©tat du jeu
        let gameState = {
            playerScore: 0,
            computerScore: 0,
            gameWinner: null
        };

        // Historique des rounds
        let roundHistory = [];
        let gameStats = {
            totalRounds: 0,
            playerWins: 0,
            computerWins: 0,
            draws: 0
        };

        // Correspondance gestes-emojis
        const gestureEmojis = {
            'pierre': '‚úä',
            'papier': '‚úã',
            'ciseaux': '‚úåÔ∏è',
            'aucun': '‚ùì',
            'erreur': '‚ùå'
        };

        // Initialisation
        document.addEventListener('DOMContentLoaded', function() {
            createParticles();
            updateGameState();
            updateHistoryDisplay(); // Initialiser l'affichage de l'historique
        });

        // Animation des particules
        function createParticles() {
            const particles = document.getElementById('particles');
            const numParticles = 50;
            
            for (let i = 0; i < numParticles; i++) {
                const particle = document.createElement('div');
                particle.className = 'particle';
                particle.style.left = Math.random() * 100 + '%';
                particle.style.width = Math.random() * 4 + 2 + 'px';
                particle.style.height = particle.style.width;
                particle.style.animationDelay = Math.random() * 8 + 's';
                particle.style.animationDuration = (Math.random() * 3 + 5) + 's';
                particles.appendChild(particle);
            }
        }

        // Gestion de la cam√©ra
        async function toggleCamera() {
            if (!cameraActive) {
                try {
                    stream = await navigator.mediaDevices.getUserMedia({ 
                        video: { 
                            width: 640, 
                            height: 480,
                            facingMode: 'user' 
                        } 
                    });
                    document.getElementById('video').srcObject = stream;
                    cameraActive = true;
                    document.getElementById('camera-status').textContent = 'Cam√©ra active';
                    
                    // D√©marrer la d√©tection de gestes
                    startGestureDetection();
                    console.log('Cam√©ra activ√©e et d√©tection d√©marr√©e');
                } catch (error) {
                    console.error('Erreur d\'acc√®s √† la cam√©ra:', error);
                    alert('Impossible d\'acc√©der √† la cam√©ra. V√©rifiez les permissions.');
                }
            }
        }

        function stopCamera() {
            if (stream) {
                stream.getTracks().forEach(track => track.stop());
                document.getElementById('video').srcObject = null;
                cameraActive = false;
                document.getElementById('camera-status').textContent = 'Cam√©ra inactive';
                
                // Arr√™ter la d√©tection de gestes
                stopGestureDetection();
                console.log('Cam√©ra arr√™t√©e et d√©tection stopp√©e');
            }
        }

        function startGestureDetection() {
            if (detectionInterval) {
                clearInterval(detectionInterval);
            }
            
            detectionInterval = setInterval(() => {
                if (cameraActive) {
                    captureAndDetectGesture();
                }
            }, 200); // Capture toutes les 200ms
        }

        function stopGestureDetection() {
            if (detectionInterval) {
                clearInterval(detectionInterval);
                detectionInterval = null;
            }
        }

        function captureAndDetectGesture() {
            const video = document.getElementById('video');
            const canvas = document.getElementById('canvas');
            const ctx = canvas.getContext('2d');
            
            // Capturer l'image de la vid√©o
            ctx.drawImage(video, 0, 0, canvas.width, canvas.height);
            
            // Convertir en base64
            const imageData = canvas.toDataURL('image/jpeg', 0.8);
            
            // Envoyer au serveur pour d√©tection
            socket.emit('detect_gesture', { image: imageData });
        }

        // Gestion du jeu
        function updateGameState() {
            fetch('/api/game/state')
                .then(response => response.json())
                .then(data => {
                    // Convertir les noms de propri√©t√©s du serveur vers le frontend
                    gameState.playerScore = data.player_score;
                    gameState.computerScore = data.computer_score;
                    gameState.gameWinner = data.game_over ? 
                        (data.player_score >= 5 ? 'player' : 'computer') : null;
                    updateScoreDisplay();
                })
                .catch(error => console.error('Erreur:', error));
        }

        function updateScoreDisplay() {
            document.getElementById('player-score').textContent = gameState.playerScore;
            document.getElementById('computer-score').textContent = gameState.computerScore;
        }

        function playRound(playerGesture) {
            if (isGameOver()) {
                console.log('Jeu termin√©, impossible de jouer');
                return;
            }

            console.log('Jeu d\'un round avec geste:', playerGesture);
            
            fetch('/play', {
                method: 'POST',
                headers: {
                    'Content-Type': 'application/json',
                },
                body: JSON.stringify({ gesture: playerGesture })
            })
            .then(response => response.json())
            .then(data => {
                console.log('R√©sultat du round:', data);
                
                // Mettre √† jour l'√©tat du jeu avec les donn√©es du serveur
                if (data.game_state) {
                    gameState.playerScore = data.game_state.player_score;
                    gameState.computerScore = data.game_state.computer_score;
                    gameState.gameWinner = data.game_state.game_over ? 
                        (data.game_state.player_score >= 5 ? 'player' : 'computer') : null;
                }
                
                updateScoreDisplay();
                showRoundResult(data);
                checkGameOver();
            })
            .catch(error => console.error('Erreur:', error));
        }

        // Fonctions de gestion de l'historique
        function addRoundToHistory(playerGesture, computerGesture, roundWinner, playerScore, computerScore) {
            const round = {
                roundNumber: roundHistory.length + 1,
                playerGesture,
                computerGesture,
                roundWinner,
                playerScore,
                computerScore,
                timestamp: new Date()
            };
            
            roundHistory.push(round);
            
            // Mettre √† jour les statistiques
            gameStats.totalRounds++;
            if (roundWinner === 'Joueur') {
                gameStats.playerWins++;
            } else if (roundWinner === 'Ordinateur') {
                gameStats.computerWins++;
            } else {
                gameStats.draws++;
            }
            
            updateHistoryDisplay();
        }

        function updateHistoryDisplay() {
            // Mettre √† jour les statistiques
            document.getElementById('total-rounds').textContent = gameStats.totalRounds;
            document.getElementById('player-wins').textContent = gameStats.playerWins;
            document.getElementById('computer-wins').textContent = gameStats.computerWins;
            document.getElementById('draws').textContent = gameStats.draws;
            
            // Mettre √† jour la liste des rounds
            const roundsList = document.getElementById('history-list');
            
            if (roundHistory.length === 0) {
                roundsList.innerHTML = '<div class="history-placeholder">Aucun round jou√©</div>';
                return;
            }
            
            roundsList.innerHTML = '';
            
            roundHistory.forEach(round => {
                const roundDiv = document.createElement('div');
                roundDiv.className = `round-item ${round.roundWinner === 'Joueur' ? 'player-win' : 
                                                   round.roundWinner === 'Ordinateur' ? 'computer-win' : 'draw'}`;
                
                roundDiv.innerHTML = `
                    <div class="round-number">Round ${round.roundNumber}</div>
                    <div class="round-gestures">
                        <span class="player-gesture">${getGestureEmoji(round.playerGesture)}</span>
                        <span class="vs">vs</span>
                        <span class="computer-gesture">${getGestureEmoji(round.computerGesture)}</span>
                    </div>
                    <div class="round-winner">${round.roundWinner === '√âgalit√©' ? 'ü§ù √âgalit√©' : round.roundWinner}</div>
                    <div class="round-score">${round.playerScore} - ${round.computerScore}</div>
                `;
                
                roundsList.appendChild(roundDiv);
            });
            
            // Faire d√©filer vers le bas pour voir le dernier round
            roundsList.scrollTop = roundsList.scrollHeight;
        }

        function clearHistory() {
            roundHistory = [];
            gameStats = {
                totalRounds: 0,
                playerWins: 0,
                computerWins: 0,
                draws: 0
            };
            updateHistoryDisplay();
        }

        function getGestureEmoji(gesture) {
            const emojis = {
                'pierre': 'ü™®',
                'papier': 'üìÑ',
                'ciseaux': '‚úÇÔ∏è'
            };
            return emojis[gesture] || gesture;
        }

        function updateLastRoundDisplay(playerGesture, computerGesture, roundWinner) {
            // Afficher la section du dernier round
            const lastRoundSection = document.getElementById('last-round-section');
            lastRoundSection.style.display = 'block';
            
            // Mettre √† jour les gestes choisis
            document.getElementById('player-choice-emoji').textContent = gestureEmojis[playerGesture] || '‚ùì';
            document.getElementById('player-choice-name').textContent = playerGesture.charAt(0).toUpperCase() + playerGesture.slice(1);
            
            document.getElementById('computer-choice-emoji').textContent = gestureEmojis[computerGesture] || '‚ùì';
            document.getElementById('computer-choice-name').textContent = computerGesture.charAt(0).toUpperCase() + computerGesture.slice(1);
            
            // Mettre √† jour le r√©sultat du round
            const roundResultElement = document.getElementById('round-result-indicator');
            const roundWinnerText = document.getElementById('round-winner-text');
            
            roundWinnerText.textContent = `üèÜ ${roundWinner} gagne !`;
            
            // Appliquer le style selon le gagnant
            roundResultElement.className = 'round-result';
            if (roundWinner === 'Joueur') {
                roundResultElement.classList.add('player-win');
            } else if (roundWinner === 'Ordinateur') {
                roundResultElement.classList.add('computer-win');
            } else {
                roundResultElement.classList.add('draw');
                roundWinnerText.textContent = 'ü§ù √âgalit√© - Aucun point !';
            }
        }

        function updateBattleDisplay(playerGesture, computerGesture, roundWinner) {
            // Mettre √† jour le geste du joueur
            document.getElementById('player-battle-emoji').textContent = gestureEmojis[playerGesture] || '‚ùì';
            document.getElementById('player-battle-name').textContent = playerGesture.charAt(0).toUpperCase() + playerGesture.slice(1);
            
            // Mettre √† jour le geste de l'IA
            document.getElementById('computer-battle-emoji').textContent = gestureEmojis[computerGesture] || '‚ùì';
            document.getElementById('computer-battle-name').textContent = computerGesture.charAt(0).toUpperCase() + computerGesture.slice(1);
            
            // Mettre √† jour le r√©sultat de la bataille
            const battleResultElement = document.getElementById('battle-result');
            const battleWinnerElement = document.getElementById('battle-winner');
            
            // R√©initialiser les classes
            battleResultElement.className = 'battle-result';
            
            if (roundWinner === 'Joueur') {
                battleWinnerElement.textContent = 'üèÜ Vous gagnez !';
                battleResultElement.classList.add('player-win');
            } else if (roundWinner === 'Ordinateur') {
                battleWinnerElement.textContent = 'ü§ñ IA gagne !';
                battleResultElement.classList.add('computer-win');
            } else {
                battleWinnerElement.textContent = 'ü§ù √âgalit√© - Aucun point';
                battleResultElement.classList.add('draw');
            }
        }

        function resetBattleDisplay() {
            // R√©initialiser les gestes
            document.getElementById('player-battle-emoji').textContent = '‚ùì';
            document.getElementById('player-battle-name').textContent = '-';
            
            document.getElementById('computer-battle-emoji').textContent = '‚ùì';
            document.getElementById('computer-battle-name').textContent = '-';
            
            // R√©initialiser le r√©sultat
            const battleResultElement = document.getElementById('battle-result');
            const battleWinnerElement = document.getElementById('battle-winner');
            
            battleResultElement.className = 'battle-result';
            battleWinnerElement.textContent = 'En attente du round...';
        }

        function showRoundResult(data) {
            const resultText = data.result === 'draw' ? 'ü§ù √âgalit√© - Aucun point marqu√©' : 
                              data.result === 'player' ? 'üèÜ Vous gagnez ce round !' : 'ü§ñ L\'IA gagne ce round !';
            
            const message = `${resultText} ${gestureEmojis[data.player_gesture]} vs ${gestureEmojis[data.computer_gesture]}`;
            
            // Ajouter le round √† l'historique
            const roundWinner = data.result === 'draw' ? '√âgalit√©' : 
                               data.result === 'player' ? 'Joueur' : 'Ordinateur';
            
            addRoundToHistory(
                data.player_gesture,
                data.computer_gesture,
                roundWinner,
                gameState.playerScore,
                gameState.computerScore
            );
            
            // Mettre √† jour le panneau des gestes avec le dernier round
            updateLastRoundDisplay(data.player_gesture, data.computer_gesture, roundWinner);
            
            // Mettre √† jour la bataille au centre
            updateBattleDisplay(data.player_gesture, data.computer_gesture, roundWinner);
            
            // Afficher le r√©sultat
            const statusElement = document.getElementById('game-status');
            const playButton = document.getElementById('play-button');
            const roundInfo = document.getElementById('round-info');
            
            statusElement.textContent = message;
            statusElement.style.color = data.result === 'player' ? '#00b894' : 
                                       data.result === 'computer' ? '#e17055' : '#ffeaa7';
            
            playButton.textContent = '‚úÖ Round termin√©';
            roundInfo.textContent = `Scores: Vous ${gameState.playerScore} - ${gameState.computerScore} IA`;
            
            // V√©rifier si la partie est termin√©e
            setTimeout(() => {
                updateGameState(); // Recharger l'√©tat du jeu
                
                setTimeout(() => {
                    console.log('üîÑ V√©rification apr√®s round - gameOver:', isGameOver(), 'autoRounds:', autoRoundsEnabled);
                    
                    if (isGameOver()) {
                        console.log('üèÅ Partie termin√©e, arr√™t des rounds automatiques');
                        checkGameOver();
                    } else if (autoRoundsEnabled) {
                        console.log('üöÄ Lancement du prochain round automatique');
                        statusElement.textContent = `Scores: Vous ${gameState.playerScore} - ${gameState.computerScore} IA`;
                        statusElement.style.color = '#74b9ff';
                        roundInfo.style.display = 'block';
                        
                        // Compte √† rebours visuel avant le prochain round
                        let countdown = 3;
                        nextRoundCountdown = setInterval(() => {
                            roundInfo.textContent = `Prochain round dans ${countdown} seconde${countdown > 1 ? 's' : ''} !`;
                            statusElement.textContent = `Prochain round dans ${countdown} seconde${countdown > 1 ? 's' : ''} !`;
                            countdown--;
                            
                            if (countdown < 0) {
                                clearInterval(nextRoundCountdown);
                                if (!isGameOver() && autoRoundsEnabled) {
                                    console.log('‚è∞ Lancement du round suivant');
                                    startGameRound();
                                } else {
                                    console.log('‚ùå Conditions non remplies pour le round suivant');
                                }
                            }
                        }, 1000);
                    } else {
                        console.log('‚è∏Ô∏è Mode automatique d√©sactiv√©, affichage du bouton play');
                        // Mode manuel - r√©afficher le bouton play
                        playButton.style.display = 'inline-block';
                        playButton.disabled = false;
                        playButton.classList.remove('disabled');
                        playButton.textContent = 'üöÄ D√©marrer les rounds automatiques';
                        statusElement.textContent = `Scores: Vous ${gameState.playerScore} - ${gameState.computerScore} IA`;
                        statusElement.style.color = '#74b9ff';
                        roundInfo.style.display = 'none';
                    }
                }, 1000);
            }, 2000);
        }

        let roundInProgress = false;
        let gestureDetectionTimeout = null;
        let countdownInterval = null;
        let detectedGestureForRound = null;
        let autoRoundsEnabled = false;
        let nextRoundCountdown = null;

        function startGameRound() {
            console.log('üéÆ startGameRound appel√©e - gameOver:', isGameOver(), 'roundInProgress:', roundInProgress);
            
            if (isGameOver()) {
                console.log('‚ùå Jeu termin√©, impossible de d√©marrer un round');
                return;
            }
            
            if (roundInProgress) {
                console.log('‚ö†Ô∏è Round d√©j√† en cours, annulation');
                return;
            }

            const playButton = document.getElementById('play-button');
            const stopButton = document.getElementById('stop-button');
            const roundInfo = document.getElementById('round-info');

            // Activer le mode automatique si c'est le premier round
            if (!autoRoundsEnabled) {
                autoRoundsEnabled = true;
                console.log('‚úÖ Mode automatique activ√©');
            }
            
            // Masquer le bouton play et afficher le bouton stop
            playButton.style.display = 'none';
            stopButton.style.display = 'block';
            
            roundInfo.style.display = 'block';
            roundInProgress = true;
            detectedGestureForRound = null;
            
            console.log('üéÆ D√©but du round - roundInProgress:', roundInProgress, 'autoRounds:', autoRoundsEnabled);

            // Activer la cam√©ra automatiquement si pas d√©j√† active
            if (!cameraActive) {
                console.log('üìπ Activation de la cam√©ra...');
                toggleCamera();
                // Attendre un peu que la cam√©ra se lance
                setTimeout(() => startCountdown(), 500);
            } else {
                console.log('üìπ Cam√©ra d√©j√† active, d√©marrage du countdown');
                startCountdown();
            }
        }

        function startCountdown() {
            let countdown = 3;
            const roundInfo = document.getElementById('round-info');
            
            // R√©initialiser le geste d√©tect√© pour ce round
            detectedGestureForRound = null;
            console.log('Nouveau round - Geste r√©initialis√©');
            
            roundInfo.textContent = `Pr√©parez-vous ! ${countdown} secondes...`;
            
            countdownInterval = setInterval(() => {
                countdown--;
                if (countdown > 0) {
                    roundInfo.textContent = `Pr√©parez-vous ! ${countdown} secondes...`;
                } else {
                    clearInterval(countdownInterval);
                    roundInfo.textContent = 'MAINTENANT ! Faites votre geste !';
                    
                    // Capturer le geste pendant 2 secondes (plus de temps)
                    gestureDetectionTimeout = setTimeout(() => {
                        finishRound();
                    }, 2000);
                }
            }, 1000);
        }

        function finishRound() {
            console.log('üèÅ finishRound appel√©e');
            
            // Nettoyer le timeout s'il existe
            if (gestureDetectionTimeout) {
                clearTimeout(gestureDetectionTimeout);
                gestureDetectionTimeout = null;
            }
            
            // Utiliser le dernier geste d√©tect√© ou un geste al√©atoire si aucun
            let playerGesture = detectedGestureForRound;
            
            console.log('Fin de round - Geste d√©tect√©:', detectedGestureForRound);
            
            if (!playerGesture || playerGesture === 'aucun' || playerGesture === 'erreur') {
                // Geste al√©atoire si aucun geste d√©tect√©
                const randomGestures = ['pierre', 'papier', 'ciseaux'];
                playerGesture = randomGestures[Math.floor(Math.random() * randomGestures.length)];
                console.log('‚ö†Ô∏è Aucun geste d√©tect√©, geste al√©atoire:', playerGesture);
                
                // Informer l'utilisateur
                const roundInfo = document.getElementById('round-info');
                roundInfo.textContent = `‚ö†Ô∏è Geste al√©atoire: ${playerGesture.toUpperCase()}`;
                roundInfo.style.color = '#e17055';
            } else {
                console.log('‚úÖ Geste utilis√© pour le round:', playerGesture);
            }
            
            // IMPORTANT : Marquer le round comme termin√© AVANT d'appeler playRound
            roundInProgress = false;
            console.log('üîÑ Round marqu√© comme termin√© - roundInProgress:', roundInProgress);
            
            // Jouer le round
            playRound(playerGesture);
        }

        // Modifier la fonction de d√©tection pour capturer le geste pendant le round
        function handleGestureDetected(gesture) {
            if (roundInProgress && gesture !== 'aucun' && gesture !== 'erreur') {
                // Toujours mettre √† jour avec le dernier geste d√©tect√©
                detectedGestureForRound = gesture;
                console.log('Geste captur√© pour le round:', gesture);
                
                // Mettre √† jour l'interface pour confirmer la capture
                const roundInfo = document.getElementById('round-info');
                roundInfo.textContent = `‚úÖ Geste captur√©: ${gesture.toUpperCase()} ${gestureEmojis[gesture]}`;
                roundInfo.style.color = '#00b894';
            }
        }

        function resetGesturesPanel() {
            // R√©initialiser la d√©tection de main
            const handStatusElement = document.getElementById('hand-status');
            handStatusElement.textContent = '‚ùå Aucune main';
            handStatusElement.parentElement.style.background = 'linear-gradient(135deg, #fd79a8, #e84393)';
            
            // R√©initialiser le geste actuel
            const gestureEmojiElement = document.getElementById('gesture-emoji');
            const gestureNameElement = document.getElementById('gesture-name');
            gestureEmojiElement.textContent = 'ü§∑';
            gestureNameElement.textContent = 'En attente';
            gestureEmojiElement.parentElement.style.background = 'linear-gradient(135deg, #636e72, #2d3436)';
            
            // Cacher la section du dernier round
            const lastRoundSection = document.getElementById('last-round-section');
            lastRoundSection.style.display = 'none';
        }

        function stopAutoRounds() {
            autoRoundsEnabled = false;
            
            // Nettoyer les timers en cours
            if (nextRoundCountdown) {
                clearInterval(nextRoundCountdown);
                nextRoundCountdown = null;
            }
            
            // Switcher les boutons
            document.getElementById('play-button').style.display = 'block';
            document.getElementById('stop-button').style.display = 'none';
            
            // Mettre √† jour l'affichage
            const statusElement = document.getElementById('game-status');
            const playButton = document.getElementById('play-button');
            
            playButton.disabled = false;
            playButton.classList.remove('disabled');
            playButton.textContent = 'üöÄ D√©marrer les rounds automatiques';
            statusElement.textContent = `Rounds automatiques arr√™t√©s - Scores: Vous ${gameState.playerScore} - ${gameState.computerScore} IA`;
            statusElement.style.color = '#e17055';
        }

        function isGameOver() {
            return gameState.gameWinner !== null;
        }

        function checkGameOver() {
            if (gameState.gameWinner) {
                const winnerText = gameState.gameWinner === 'player' ? 
                    'ÔøΩ F√âLICITATIONS ! VOUS AVEZ GAGN√â LA PARTIE !' : 
                    'üòî DOMMAGE ! L\'IA A GAGN√â LA PARTIE !';
                
                const finalScore = `Score final: Vous ${gameState.playerScore} - ${gameState.computerScore} IA`;
                
                document.getElementById('game-status').innerHTML = `
                    <div style="font-size: 1.4em; margin-bottom: 10px; font-weight: bold;">${winnerText}</div>
                    <div style="font-size: 1.1em; margin-bottom: 20px; color: #636e72;">${finalScore}</div>
                    <button onclick="resetGame()" class="btn" style="font-size: 1.2em; padding: 15px 30px; background: linear-gradient(135deg, #00b894, #55a3ff);">
                        üîÑ Nouvelle partie (5 points)
                    </button>
                `;
                
                // D√©sactiver le bouton de jeu
                const playButton = document.getElementById('play-button');
                playButton.disabled = true;
                playButton.classList.add('disabled');
                playButton.textContent = 'üèÅ Partie termin√©e';
                
                // Cacher les infos de round
                document.getElementById('round-info').style.display = 'none';
            }
        }

        function resetGame() {
            fetch('/reset', { method: 'POST' })
                .then(response => response.json())
                .then(data => {
                    // Convertir les noms de propri√©t√©s du serveur vers le frontend
                    gameState.playerScore = data.player_score;
                    gameState.computerScore = data.computer_score;
                    gameState.gameWinner = null;
                    
                    // Vider l'historique
                    clearHistory();
                    
                    // R√©initialiser le panneau des gestes
                    resetGesturesPanel();
                    
                    // R√©initialiser l'affichage de bataille au centre
                    resetBattleDisplay();
                    
                    // R√©initialiser le mode automatique
                    autoRoundsEnabled = false;
                    if (nextRoundCountdown) {
                        clearInterval(nextRoundCountdown);
                        nextRoundCountdown = null;
                    }
                    
                    updateScoreDisplay();
                    document.getElementById('game-status').textContent = 'Nouvelle partie ! Premier √† 5 points gagne ! (Rounds automatiques)';
                    document.getElementById('game-status').style.color = '#74b9ff';
                    
                    // R√©activer le bouton de jeu
                    const playButton = document.getElementById('play-button');
                    const stopButton = document.getElementById('stop-button');
                    playButton.disabled = false;
                    playButton.classList.remove('disabled');
                    playButton.textContent = 'üöÄ D√©marrer les rounds automatiques';
                    playButton.style.display = 'block';
                    stopButton.style.display = 'none';
                    
                    // Cacher les infos de round
                    document.getElementById('round-info').style.display = 'none';
                    
                    // R√©initialiser les variables de round
                    roundInProgress = false;
                    detectedGestureForRound = null;
                    
                    // Nettoyer les timers
                    if (gestureDetectionTimeout) {
                        clearTimeout(gestureDetectionTimeout);
                        gestureDetectionTimeout = null;
                    }
                    if (countdownInterval) {
                        clearInterval(countdownInterval);
                        countdownInterval = null;
                    }
                    
                    console.log('Nouvelle partie d√©marr√©e !');
                })
                .catch(error => console.error('Erreur lors de la r√©initialisation:', error));
        }

        // Communication WebSocket
        socket.on('connect', function() {
            console.log('Connect√© au serveur via WebSocket');
        });

        socket.on('disconnect', function() {
            console.log('D√©connect√© du serveur');
        });

        // √âcouter la d√©tection de gestes
        socket.on('gesture_detected', function(data) {
            console.log('üì° Geste d√©tect√© via socket:', data, 'roundInProgress:', roundInProgress);
            updateDetectedHand(data.gesture, data.hand_detected);
            
            // Si un geste valide est d√©tect√© et que le jeu n'est pas termin√©
            if (data.gesture !== 'aucun' && data.gesture !== 'erreur' && !isGameOver()) {
                const gestureElement = document.getElementById('gesture-feedback');
                if (gestureElement) {
                    gestureElement.textContent = 
                        `Geste d√©tect√©: ${data.gesture.toUpperCase()} ${gestureEmojis[data.gesture]}`;
                }
                
                // Capturer le geste si un round est en cours
                handleGestureDetected(data.gesture);
            }
        });

        function updateDetectedHand(gesture, handDetected) {
            // Mettre √† jour l'ancien √©l√©ment (pour compatibilit√©)
            const currentGestureElement = document.getElementById('current-gesture');
            
            if (currentGestureElement) {
                if (handDetected) {
                    currentGestureElement.textContent = `Main d√©tect√©e: ${gesture.toUpperCase()} ${gestureEmojis[gesture]}`;
                    currentGestureElement.style.background = 'linear-gradient(135deg, #00b894, #55a3ff)';
                } else {
                    currentGestureElement.textContent = 'Aucune main d√©tect√©e';
                    currentGestureElement.style.background = 'linear-gradient(135deg, #636e72, #2d3436)';
                }
            }
            
            // Mettre √† jour le nouveau panneau des gestes
            const handStatusElement = document.getElementById('hand-status');
            const gestureEmojiElement = document.getElementById('gesture-emoji');
            const gestureNameElement = document.getElementById('gesture-name');
            
            if (handDetected) {
                handStatusElement.textContent = '‚úÖ Main d√©tect√©e';
                handStatusElement.parentElement.style.background = 'linear-gradient(135deg, #00b894, #00a085)';
                
                if (gesture && gesture !== 'aucun' && gesture !== 'erreur') {
                    gestureEmojiElement.textContent = gestureEmojis[gesture] || 'ü§∑';
                    gestureNameElement.textContent = gesture.charAt(0).toUpperCase() + gesture.slice(1);
                    gestureEmojiElement.parentElement.style.background = 'linear-gradient(135deg, #74b9ff, #0984e3)';
                } else {
                    gestureEmojiElement.textContent = 'ü§∑';
                    gestureNameElement.textContent = 'Geste non reconnu';
                    gestureEmojiElement.parentElement.style.background = 'linear-gradient(135deg, #fdcb6e, #e17055)';
                }
            } else {
                handStatusElement.textContent = '‚ùå Aucune main';
                handStatusElement.parentElement.style.background = 'linear-gradient(135deg, #fd79a8, #e84393)';
                
                gestureEmojiElement.textContent = 'ü§∑';
                gestureNameElement.textContent = 'En attente';
                gestureEmojiElement.parentElement.style.background = 'linear-gradient(135deg, #636e72, #2d3436)';
            }
        }

        // Gestion des erreurs
        window.addEventListener('error', function(event) {
            console.error('Erreur JavaScript:', event.error);
        });

        // Nettoyage lors de la fermeture de la page
        window.addEventListener('beforeunload', function() {
            if (stream) {
                stream.getTracks().forEach(track => track.stop());
            }
            stopGestureDetection();
        });
    </script>
</body>
</html>