import cv2
import mediapipe as mp
import numpy as np
import random
import time
from game_logic import finger_up, detect_sign, get_result

# Configuration de MediaPipe
mp_hands = mp.solutions.hands
mp_drawing = mp.solutions.drawing_utils
mp_drawing_styles = mp.solutions.drawing_styles

# Constantes pour le jeu
COUNTDOWN_TIME = 3  # Temps de compte Ã  rebours en secondes
ROUND_PAUSE = 2    # Pause entre les manches en secondes
WINDOW_WIDTH = 1280
WINDOW_HEIGHT = 720

def draw_text_with_background(frame, text, position, scale=1, color=(255, 255, 255), thickness=2):
    """
    Dessine du texte avec un fond sombre pour une meilleure lisibilitÃ©
    """
    font = cv2.FONT_HERSHEY_SIMPLEX
    (text_width, text_height), baseline = cv2.getTextSize(text, font, scale, thickness)
    
    # Dessiner le fond
    padding = 5
    cv2.rectangle(frame,
                 (position[0] - padding, position[1] - text_height - padding),
                 (position[0] + text_width + padding, position[1] + padding),
                 (0, 0, 0), -1)
    
    # Dessiner le texte
    cv2.putText(frame, text, position, font, scale, color, thickness)

# --- Programme principal ---
cap = cv2.VideoCapture(0)

# Configuration de la rÃ©solution de la webcam
cap.set(cv2.CAP_PROP_FRAME_WIDTH, WINDOW_WIDTH)
cap.set(cv2.CAP_PROP_FRAME_HEIGHT, WINDOW_HEIGHT)

# Configuration plus sensible des mains
hands = mp_hands.Hands(
    max_num_hands=1,                    # On ne suit qu'une seule main
    model_complexity=1,                 # 0 plus rapide, 1 plus prÃ©cis
    min_detection_confidence=0.6,       # Seuil de dÃ©tection plus bas pour plus de sensibilitÃ©
    min_tracking_confidence=0.6         # Seuil de suivi plus bas pour plus de stabilitÃ©
)

# Variables du jeu
score_joueur = 0
score_ordi = 0
last_play_time = 0
computer_choice = "..."
game_state = "waiting"  # Ã‰tats possibles: "waiting", "countdown", "playing"
countdown_start = 0
current_round_result = None
player_choice = "inconnu"

    while cap.isOpened():
        ret, frame = cap.read()
        if not ret:
            break

        frame = cv2.flip(frame, 1)
        rgb = cv2.cvtColor(frame, cv2.COLOR_BGR2RGB)
        result = hands.process(rgb)

        player_choice = "inconnu"

        # DÃ©tection des mains
        if result.multi_hand_landmarks:
            for hand_landmarks, handedness in zip(result.multi_hand_landmarks, result.multi_handedness):
                mp_drawing.draw_landmarks(frame, hand_landmarks, mp_hands.HAND_CONNECTIONS)
                label = handedness.classification[0].label  # Left ou Right

                sign = detect_sign(hand_landmarks.landmark)

                if label == "Right":
                    player_choice = sign

        # Jeu toutes les 3 secondes
        current_time = time.time()
        if current_time - last_play_time > 3 and player_choice != "inconnu":
            computer_choice = random.choice(["pierre", "feuille", "ciseaux"])
            gagnant = get_result(player_choice, computer_choice)

            if gagnant == "Joueur":
                score_joueur += 1
            elif gagnant == "Ordinateur":
                score_ordi += 1

            last_play_time = current_time

        # --- Affichage ---
        cv2.putText(frame, f"Joueur: {player_choice}", (10, 50),
                    cv2.FONT_HERSHEY_SIMPLEX, 1.1, (0, 255, 0), 3)
        cv2.putText(frame, f"Ordinateur: {computer_choice}", (10, 100),
                    cv2.FONT_HERSHEY_SIMPLEX, 1.1, (0, 255, 255), 3)
        cv2.putText(frame, f"Score Joueur: {score_joueur}", (10, 180),
                    cv2.FONT_HERSHEY_SIMPLEX, 0.9, (255, 255, 255), 2)
        cv2.putText(frame, f"Score Ordi: {score_ordi}", (10, 210),
                    cv2.FONT_HERSHEY_SIMPLEX, 0.9, (255, 255, 255), 2)
        cv2.putText(frame, f"Press ESC pour quitter", (10, 470),
                    cv2.FONT_HERSHEY_SIMPLEX, 0.7, (255, 0, 0), 2)

        cv2.imshow("ðŸ¤– Shifumi AI - Double joueur avec score", frame)

        if cv2.waitKey(5) & 0xFF == 27:
            break

cap.release()
cv2.destroyAllWindows()
